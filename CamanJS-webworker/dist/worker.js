// Generated by CoffeeScript 1.9.1
(function() {
  var $, Calculate, Log, Logger, Pixel, Util, parse, slice,
    slice1 = [].slice,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Calculate = (function() {
    function Calculate() {}

    Calculate.distance = function(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    };

    Calculate.randomRange = function(min, max, getFloat) {
      var rand;
      if (getFloat == null) {
        getFloat = false;
      }
      rand = min + (Math.random() * (max - min));
      if (getFloat) {
        return rand.toFixed(getFloat);
      } else {
        return Math.round(rand);
      }
    };

    Calculate.luminance = function(rgba) {
      return (0.299 * rgba.r) + (0.587 * rgba.g) + (0.114 * rgba.b);
    };

    Calculate.bezier = function(start, ctrl1, ctrl2, end, lowBound, highBound) {
      var bezier, clamp, controlPoints, endX, i, j, k, l, lerp, next, prev, ref, t;
      if (lowBound == null) {
        lowBound = 0;
      }
      if (highBound == null) {
        highBound = 255;
      }
      if (start[0] instanceof Array) {
        controlPoints = start;
        lowBound = ctrl1;
        highBound = ctrl2;
      } else {
        controlPoints = [start, ctrl1, ctrl2, end];
      }
      if (controlPoints.length < 2) {
        throw "Invalid number of arguments to bezier";
      }
      bezier = {};
      lerp = function(a, b, t) {
        return a * (1 - t) + b * t;
      };
      clamp = function(a, min, max) {
        return Math.min(Math.max(a, min), max);
      };
      for (i = k = 0; k < 1000; i = ++k) {
        t = i / 1000;
        prev = controlPoints;
        while (prev.length > 1) {
          next = [];
          for (j = l = 0, ref = prev.length - 2; 0 <= ref ? l <= ref : l >= ref; j = 0 <= ref ? ++l : --l) {
            next.push([lerp(prev[j][0], prev[j + 1][0], t), lerp(prev[j][1], prev[j + 1][1], t)]);
          }
          prev = next;
        }
        bezier[Math.round(prev[0][0])] = Math.round(clamp(prev[0][1], lowBound, highBound));
      }
      endX = controlPoints[controlPoints.length - 1][0];
      bezier = Caman.Calculate.missingValues(bezier, endX);
      if (bezier[endX] == null) {
        bezier[endX] = bezier[endX - 1];
      }
      return bezier;
    };

    Calculate.hermite = function(controlPoints, lowBound, highBound) {
      var add, clamp, count, endX, fac0, fac1, fac2, fac3, i, j, k, l, lerp, m0, m1, mul, p, p0, p1, pointsPerSegment, pointsPerStep, pos, ref, ref1, ret, sub, t;
      if (controlPoints.length < 2) {
        throw "Invalid number of arguments to hermite";
      }
      ret = {};
      lerp = function(a, b, t) {
        return a * (1 - t) + b * t;
      };
      add = (function(_this) {
        return function(a, b, c, d) {
          return [a[0] + b[0] + c[0] + d[0], a[1] + b[1] + c[1] + d[1]];
        };
      })(this);
      mul = (function(_this) {
        return function(a, b) {
          return [a[0] * b[0], a[1] * b[1]];
        };
      })(this);
      sub = (function(_this) {
        return function(a, b) {
          return [a[0] - b[0], a[1] - b[1]];
        };
      })(this);
      clamp = function(a, min, max) {
        return Math.min(Math.max(a, min), max);
      };
      count = 0;
      for (i = k = 0, ref = controlPoints.length - 2; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        p0 = controlPoints[i];
        p1 = controlPoints[i + 1];
        pointsPerSegment = p1[0] - p0[0];
        pointsPerStep = 1 / pointsPerSegment;
        if (i === controlPoints.length - 2) {
          pointsPerStep = 1 / (pointsPerSegment - 1);
        }
        p = i > 0 ? controlPoints[i - 1] : p0;
        m0 = mul(sub(p1, p), [0.5, 0.5]);
        p = i < controlPoints.length - 2 ? controlPoints[i + 2] : p1;
        m1 = mul(sub(p, p0), [0.5, 0.5]);
        for (j = l = 0, ref1 = pointsPerSegment; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
          t = j * pointsPerStep;
          fac0 = 2.0 * t * t * t - 3.0 * t * t + 1.0;
          fac1 = t * t * t - 2.0 * t * t + t;
          fac2 = -2.0 * t * t * t + 3.0 * t * t;
          fac3 = t * t * t - t * t;
          pos = add(mul(p0, [fac0, fac0]), mul(m0, [fac1, fac1]), mul(p1, [fac2, fac2]), mul(m1, [fac3, fac3]));
          ret[Math.round(pos[0])] = Math.round(clamp(pos[1], lowBound, highBound));
          count += 1;
        }
      }
      endX = controlPoints[controlPoints.length - 1][0];
      ret = Caman.Calculate.missingValues(ret, endX);
      return ret;
    };

    Calculate.missingValues = function(values, endX) {
      var i, j, k, l, leftCoord, ref, ref1, ref2, ret, rightCoord;
      if (Object.keys(values).length < endX + 1) {
        ret = {};
        for (i = k = 0, ref = endX; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
          if (values[i] != null) {
            ret[i] = values[i];
          } else {
            leftCoord = [i - 1, ret[i - 1]];
            for (j = l = ref1 = i, ref2 = endX; ref1 <= ref2 ? l <= ref2 : l >= ref2; j = ref1 <= ref2 ? ++l : --l) {
              if (values[j] != null) {
                rightCoord = [j, values[j]];
                break;
              }
            }
            ret[i] = leftCoord[1] + ((rightCoord[1] - leftCoord[1]) / (rightCoord[0] - leftCoord[0])) * (i - leftCoord[0]);
          }
        }
        return ret;
      }
      return values;
    };

    return Calculate;

  })();

  slice = Array.prototype.slice;

  $ = function(sel, root) {
    if (root == null) {
      root = document;
    }
    if (typeof sel === "object" || (typeof exports !== "undefined" && exports !== null)) {
      return sel;
    }
    return root.querySelector(sel);
  };

  Util = (function() {
    function Util() {}

    Util.uniqid = (function() {
      var id;
      id = 0;
      return {
        get: function() {
          return id++;
        }
      };
    })();

    Util.extend = function() {
      var copy, dest, k, len, obj, prop, src;
      obj = arguments[0], src = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
      dest = obj;
      for (k = 0, len = src.length; k < len; k++) {
        copy = src[k];
        for (prop in copy) {
          if (!hasProp.call(copy, prop)) continue;
          dest[prop] = copy[prop];
        }
      }
      return dest;
    };

    Util.clampRGB = function(val) {
      if (val < 0) {
        return 0;
      }
      if (val > 255) {
        return 255;
      }
      return val;
    };

    Util.copyAttributes = function(from, to, opts) {
      var attr, k, len, ref, ref1, results;
      if (opts == null) {
        opts = {};
      }
      ref = from.attributes;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        attr = ref[k];
        if ((opts.except != null) && (ref1 = attr.nodeName, indexOf.call(opts.except, ref1) >= 0)) {
          continue;
        }
        results.push(to.setAttribute(attr.nodeName, attr.nodeValue));
      }
      return results;
    };

    Util.dataArray = function(length) {
      if (length == null) {
        length = 0;
      }
      if (Caman.NodeJS || (window.Uint8Array != null)) {
        return new Uint8Array(length);
      }
      return new Array(length);
    };

    return Util;

  })();

  Pixel = (function() {
    Pixel.coordinatesToLocation = function(x, y, width) {
      return (y * width + x) * 4;
    };

    Pixel.locationToCoordinates = function(loc, width) {
      var x, y;
      y = Math.floor(loc / (width * 4));
      x = (loc % (width * 4)) / 4;
      return {
        x: x,
        y: y
      };
    };

    function Pixel(r, g, b1, a1, c1) {
      this.r = r != null ? r : 0;
      this.g = g != null ? g : 0;
      this.b = b1 != null ? b1 : 0;
      this.a = a1 != null ? a1 : 255;
      this.c = c1 != null ? c1 : null;
      this.loc = 0;
    }

    Pixel.prototype.setContext = function(c) {
      return this.c = c;
    };

    Pixel.prototype.locationXY = function() {
      var x, y;
      y = this.imageHeight - Math.floor(this.loc / (this.imageWidth * 4));
      x = (this.loc % (this.imageWidth * 4)) / 4;
      return {
        x: x,
        y: y
      };
    };

    Pixel.prototype.pixelAtLocation = function(loc) {
      if (this.c == null) {
        throw "Requires a CamanJS context";
      }
      return new Pixel(this.c.pixelData[loc], this.c.pixelData[loc + 1], this.c.pixelData[loc + 2], this.c.pixelData[loc + 3], this.c);
    };

    Pixel.prototype.getPixelRelative = function(horiz, vert) {
      var newLoc;
      if (this.c == null) {
        throw "Requires a CamanJS context";
      }
      newLoc = this.loc + (this.c.dimensions.width * 4 * (vert * -1)) + (4 * horiz);
      if (newLoc > this.c.pixelData.length || newLoc < 0) {
        return new Pixel(0, 0, 0, 255, this.c);
      }
      return this.pixelAtLocation(newLoc);
    };

    Pixel.prototype.putPixelRelative = function(horiz, vert, rgba) {
      var nowLoc;
      if (this.c == null) {
        throw "Requires a CamanJS context";
      }
      nowLoc = this.loc + (this.c.dimensions.width * 4 * (vert * -1)) + (4 * horiz);
      if (newLoc > this.c.pixelData.length || newLoc < 0) {
        return;
      }
      this.c.pixelData[newLoc] = rgba.r;
      this.c.pixelData[newLoc + 1] = rgba.g;
      this.c.pixelData[newLoc + 2] = rgba.b;
      this.c.pixelData[newLoc + 3] = rgba.a;
      return true;
    };

    Pixel.prototype.getPixel = function(x, y) {
      var loc;
      if (this.c == null) {
        throw "Requires a CamanJS context";
      }
      loc = this.coordinatesToLocation(x, y, this.width);
      return this.pixelAtLocation(loc);
    };

    Pixel.prototype.putPixel = function(x, y, rgba) {
      var loc;
      if (this.c == null) {
        throw "Requires a CamanJS context";
      }
      loc = this.coordinatesToLocation(x, y, this.width);
      this.c.pixelData[loc] = rgba.r;
      this.c.pixelData[loc + 1] = rgba.g;
      this.c.pixelData[loc + 2] = rgba.b;
      return this.c.pixelData[loc + 3] = rgba.a;
    };

    Pixel.prototype.toString = function() {
      return this.toKey();
    };

    Pixel.prototype.toHex = function(includeAlpha) {
      var hex;
      if (includeAlpha == null) {
        includeAlpha = false;
      }
      hex = '#' + this.r.toString(16) + this.g.toString(16) + this.b.toString(16);
      if (includeAlpha) {
        return hex + this.a.toString(16);
      } else {
        return hex;
      }
    };

    return Pixel;

  })();

  Logger = (function() {
    function Logger() {
      var k, len, name, ref;
      ref = ['log', 'info', 'warn', 'error'];
      for (k = 0, len = ref.length; k < len; k++) {
        name = ref[k];
        this[name] = (function(name) {
          return function() {
            var args, e;
            args = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
            try {
              return console[name].apply(console, 'Web worker', args);
            } catch (_error) {
              e = _error;
              return console[name]('Web worker', args);
            }
          };
        })(name);
      }
      this.debug = this.log;
    }

    return Logger;

  })();

  Log = new Logger();

  parse = function(str) {
    return JSON.parse(str, function(key, value) {
      var prefix;
      prefix = value.substring(0, 8);
      if (prefix === 'function') {
        return eval('(' + value + ')');
      }
      return value;
    });
  };

  self.imageData = 0;

  self.processFn = void 0;

  self.processname = void 0;


  /* TODO
  - edit filters to manipulate arraybuffers instead of contexts
  - edit filters to not access function context (this.*)
  - return altered array buffer
   */

  self.renderFilter = (function(_this) {
    return function() {
      var i, k, pixel, ref, results;
      pixel = new Pixel();
      pixel.setContext(_this.c);
      results = [];
      for (i = k = 0, ref = self.imageData.length; k < ref; i = k += 4) {
        pixel.loc = i;
        pixel.r = self.imageData[i];
        pixel.g = self.imageData[i + 1];
        pixel.b = self.imageData[i + 2];
        pixel.a = self.imageData[i + 3];
        self.processFn(pixel);
        self.imageData[i] = Util.clampRGB(pixel.r);
        self.imageData[i + 1] = Util.clampRGB(pixel.g);
        self.imageData[i + 2] = Util.clampRGB(pixel.b);
        results.push(self.imageData[i + 3] = Util.clampRGB(pixel.a));
      }
      return results;
    };
  })(this);

  self.addEventListener('message', function(e) {
    var key, params;
    if (e.data.cmd != null) {
      switch (e.data.cmd) {
        case 'id':
          return this.id = e.data.id;
        case "renderFilter":
          if (self.imageData.byteLength) {
            self.processFn = parse(e.data.filter);
            if (e.data.parameters != null) {
              params = JSON.parse(e.data.parameters);
              for (key in params) {
                this[key] = params[key];
              }
            }
            self.processname = e.data.name;
            self.renderFilter();
            return self.postMessage({
              'cmd': 'filterDone',
              'id': this.id
            });
          } else {

          }
          break;
        case "imageSize":
          this.imageHeight = e.data.height;
          return this.imageWidth = e.data.width;
        case "sendResults":
          return self.postMessage(self.imageData.buffer, [self.imageData.buffer]);
        default:
          return Log.debug('unknown command');
      }
    } else if (typeof e.data === 'string') {
      return self.processFn = parse(e.data);
    } else {
      self.imageData = new Uint8Array(e.data);
      if (self.imageData.length === 0) {
        Log.debug('0 length image');
        return Log.debug(e.data);
      }
    }
  });

}).call(this);
